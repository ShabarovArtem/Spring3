ArrayList - массив который может изменять свой размер
В основе его лежит Object

в массиве если нужно ставить элемент между, то все сбоку двинулись на право, а в LinkedList меняются лишь ссылки, это намного быстрее

int index1 = Collections.binarySearch(arrayList, 12) находим индекс под которым число 12, массив arrayList делим попалам, если число по середине больше искомого
то левая часть делиться пополам и происходит тоже самое, если меньше то правая также, этот способ лучше подходит для поиска
перед тем как искать число, нужно его отсортировать
Collections.sort(arrayList);
int index1 = Collections.binarySearch(arrayList, 12);
если число не найдено выводится отрицательное число

Collections.sort(employeeList); //сортируем, тут нужно явно указывать способ сортировки
        //с помощью compareTo в классе Employee

int index2 = Collections.binarySearch(employeeList,new Employee(15,"Sasha",125));
        //ищем определенный индекс по значениям
    -------------------------------------------------------------------------------------------------
Сортировка массивов
  int[]array = {-3,8,12,-8,7,1,150};
        System.out.println(Arrays.toString(array));
        Arrays.sort(array);
        System.out.println(Arrays.toString(array));
[-3, 8, 12, -8, 7, 1, 150]
[-8, -3, 1, 7, 8, 12, 150]
int index2 = Arrays.binarySearch(array,125);
для поиска индекса в массиве

Collections для работы c листом, Arrays с массивом
для того, чтобы отсортировать в обратном порядке нужно вместо sort, reverse
Collections.reverse(employeeList);

Collections.shuffle(employeeList);//перемешивает в рандомном порядке
-----------------------------------------------------------------------------------------------
Vector - устаревший класс, содержит массив элементы object, не рекомендован для использования, схож с arrraylist
-----------------------------------------------------------------------------------------------
Stack - устаревший класс, использует принцип LIFO, не рекомендован для использования, схож с arrraylist
ПОСЛЕДНИЙ ВОШЕЛ, ПЕРВЫЙ ВЫШЕЛ
push - вставляет, pop - возращает и удаляет
isEmpty - проверка на пустоту
peek возращает,но не удаляет
-----------------------------------------------------------------------------------------------
Map - ключ и значение храниться как пара
Элементы HashMap являются пары ключ/значение
HashMap не запоминает порядок добавления элементов
Его методы работают очень быстро
Ключи должны быть уникальными, могут быть null, также и со значениями
В качестве ключа и значений может быть любой тип данных
-----------------------------------------------------------------------------------------------
после того, как переопределили equals, нужно переопределить hashcode

Map<Student, Double> map = new HashMap<>(); создаем map

hashCode это преобразование любых объектов в int
на вход поступает объект, на выход int

Initial capacity - начальный размер массива
Load factor - коэф того, насколько массив должен быть заполнен, после чего его размер будет увеличен вдвое
рекомендуемо чтобы объекты которые стояли в роли ключа были неизменяемые
-----------------------------------------------------------------------------------------------
TreeMap в отличие от HashMap, хранит элементы в сортированном по возрастанию порядке(по ключу)
работает быстро, но не как HashMap
значения могут быть не уникальными, но если ключи повторяются то перезаписываются,как и в HashMap
put,get, remove
System.out.println(treeMap);//вывод
System.out.println(treeMap.descendingMap());//по убыванию
System.out.println(treeMap.tailMap(7.3));//от и выше
System.out.println(treeMap.headMap(7.3));//от и ниже
System.out.println(treeMap.lastEntry(7.3));//самый последний
System.out.println(treeMap.firstEntry(7.3));//самый первый
-----------------------------------------------------------------------------------------------
LinkedHashMap является наследником HashMap, хранит информацию о порядке добавления или их использования, скорость чуть ниже
LinkedHashMap<Double, Student> lhm =
                new LinkedHashMap<>(16,0.75f,false);
        //размер,заполняемость, способ сортировки, false по добавлению, true по использованию (put, get можно считать за использование)
-----------------------------------------------------------------------------------------------
Set коллекция, хранящая уникальные элементы
методы данной коллекции очень быстры
не запоминает порядок добавления, может содержать null
не содержит дубликаты
add, remove, size, isEmpty, contains (проверяет есть ли указанный),
get нет, тк нет смысла
HashSet мы заполняем, он записывает все как ключи, а элементы генерит сам константные

Чтобы объединить два HashSet, мы создаем новый, который основывется на первом и объединяем со вторым
        HashSet<Integer> hashSet1 = new HashSet<>();
        hashSet1.add(2);

        HashSet<Integer> hashSet2 = new HashSet<>();
        hashSet2.add(3);

        HashSet<Integer> union = new HashSet<>(hashSet1);
        union.addAll(hashSet2); Объединяет

        addAll Объединяет
        retainAll Находит пересечения
        removeAll из первого удаляет все элементы второго
-----------------------------------------------------------------------------------------------
TreeSet хранит элементы в отсортированном виде по возрастанию
first - выводит на первом месте
last - последний
headSet - ниже чем
tailsSet - выше чем
subSet - между, принимает два параметра
лучше переназначать equals, убрать не нужные сравнения и в hashCode Тоже
-----------------------------------------------------------------------------------------------
Queue - коллекция, хранящая последовательность элементов, добавляется элемент в конец очереди
используется из начала очереди - правило FIFO
LinkedList наследник Deque, а он Queue, очень часто применяется когда нужна очередь

//если очередь ограничена и заполнена, при add вылез ошибка
        //если offer, то просто не добавилось бы, без ошибки
queue.remove(); //если не указывать, то удаляет первый, если элементов вообще нет, то будет ошибка
        queue.poll();// также удаляет, но при отсутствии элементов не выдает ошибку, возвращает null
        System.out.println(queue.element());// указывает первый элемент
        System.out.println(queue.peek());// указывает первый элемент, в случае отсутствия не выкидывает ошибку, а null














